# -*- coding: utf-8 -*-
"""QR factorization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u4pzG_8Jntp5xTDfVaC8w2ogMoD8B1gD
"""

#header files
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import scipy.io as spio

#dataset taken from website named as ollivette faces
from sklearn.datasets import fetch_olivetti_faces#
data=fetch_olivetti_faces()

#defining data size
print(data.data.shape)
print(data.target.shape)#defining the dimensions
print(data.target)

X=data.data[np.arange(0,400,10)]#data taken for distinct values
A=np.matmul(X,np.transpose(X))/len(X)#forming A as an input
print(A)

def QR_decomposition(A):
  m,n=A.shape#row and columns of the matrix

  u=np.empty((n,n))#initialising u
  Q=np.empty((n,n))#initialising Q

  Q[:,0]=A[:,0]/np.linalg.norm(A[:,0])#finding norm of the first columns

  for i in range(1,m):
    u[:,i]=A[:,i]#initialising A in U
    for j in range(i):
      u[:,i]=u[:,i]-((np.matmul(Q[:,j],A[:,i]))*Q[:,j])#substracting all other vectors from the previous vector to make it orthonormal to one another
    Q[:,i]=u[:,i]/np.linalg.norm(u[:,i])#correspondingly finding the norm of the U and storing in Q

  R=np.zeros((m,n))#defination of R
  for i in range(m):
    for j in range(i,n):
      R[i,j]=np.matmul(Q[:,i],A[:,j])#matrix multiplication of the transpose of the q with coefficient of the a

  return Q,R  #output as Q and R

Q,R=QR_decomposition(A)
print('\nA:\n',A)#display A
print('\nQ:\n', Q)# display Q
print('\nR:\n', R)# display R

#graphical representation of A
spio.savemat('A.mat',{'A':A})
sns.set()
print("A")
ax=sns.heatmap(A)
plt.show()

#graphical representation of Q
print("Q")
ax=sns.heatmap(Q)
plt.show()

#graphical representation of R
print("R")
ax=sns.heatmap(R)
plt.show()

"""comparing with inbuilt function

"""

q, r = np.linalg.qr(A)
print('\nA:\n',A)#display A
print('\nQ:\n', q)#display Q
print('\nR:\n', r)#display R